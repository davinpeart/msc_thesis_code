functions {  // mean & variance parameterization of skellam lpmf    real skellam_lpmf(int y, real mu, real sigma) {      if(mu == 0) {         return(- sigma + log_modified_bessel_first_kind(abs(y), sqrt(sigma^2)));      } else {        return(- sigma + ((log(sigma + mu) - log(sigma - mu)) * y / 2) +          log_modified_bessel_first_kind(abs(y), sqrt(sigma^2 - mu^2)));      }    }    // skellam rng    int skellam_rng(real mu, real sigma) {      return(poisson_rng((sigma + mu) / 2) - poisson_rng((sigma - mu) / 2));    }}data {  // observations and fixed effects    int<lower=1> N;  // number of observations    int Y[N];  // response variable    int<lower=1> K;  // number of fixed effects    matrix[N, K] X;  // fixed effect design matrix    // random effects    int<lower=1> N_I;  // number of subjects    int<lower=1,upper=N_I> I[N];  // subject identifier}parameters {  // fixed effects    vector[K] beta;  // non-standardized regression coefficients    vector[K] beta_phi;  // log positive real dispersion parameter = standard deviation of normal    vector[K] beta_delta;  // log positive real difference between mean and variance of skellam      // random effects    matrix[3 * K, N_I] z_I;  // standardized subject intercepts and slopes    vector[3 * K] sigma_I;  // log sd for subject intercepts and slopes    cholesky_factor_corr[3 * K] L_I;  // correlation matrix for subject intercepts and slopes    vector[N] mu;  // mixture mean}transformed parameters {  // random effects    vector<lower=0>[3 * K] sigma = exp(sigma_I);    matrix[3 * K, N_I] z; // non-centered subject intercepts and slopes    z = diag_pre_multiply(sigma, L_I) * z_I; // regression terms    vector[N] theta;    for(n in 1:N) {        theta[n] = X[n, ] * (beta + exp(z[1:K, I[n]]));    }    vector<lower=0>[N] phi;    for(n in 1:N) {        phi[n] = X[n, ] * (exp(beta_phi + z[(K + 1):(2 * K), I[n]]));    }    vector<lower=0>[N] delta;    for(n in 1:N) {        delta[n] = X[n, ] * (exp(beta_delta + z[(2 * K + 1):(3 * K), I[n]]));    }}model {  // priors    //  fixed effects      beta[1:4] ~ normal(2, 2);  // positive prior for generalization coefficients      beta[5:K] ~ normal(0, 2.5);  // 0-centered prior for effects of sex/phase      beta_phi ~ normal(0, 2.5);  // weakly informative prior for ancillary dispersion      beta_delta ~ normal(0, 2);  // weakly informative prior for ancillary difference        // random effects      L_I ~ lkj_corr_cholesky(1);  // uniform lkj prior on cholesky factors      sigma_I ~ normal(0, .8);  // small normal on log subject sd      to_vector(z_I) ~ normal(0, 1);  // standard normal on standardized effects    // mixture    for(n in 1:N) {  // normal hyperprior on means      target += normal_lpdf(mu[n] | theta[n], phi[n]);    }    for(n in 1:N) {  // skellam likelihood on means      target += skellam_lpmf(Y[n] | mu[n], abs(mu[n]) + delta[n]);    }}generated quantities {  // recover omega    matrix[3 * K, 3 * K] omega;    omega = multiply_lower_tri_self_transpose(L_I);    // replications for posterior predictive checks    vector[K] beta_rep;  // beta replications    beta_rep = multi_normal_rng(beta, quad_form_diag(omega[1:K, 1:K], sigma[1:K]));    vector[K] beta_phi_rep;  // beta_phi replications    beta_phi_rep = multi_normal_rng(beta_phi,     quad_form_diag(omega[(K + 1):(2 * K), (K + 1):(2 * K)], sigma[(K + 1):(2 * K)]));    vector[K] beta_delta_rep;  // beta_delta replications    beta_delta_rep = multi_normal_rng(beta_delta,     quad_form_diag(omega[(2 * K + 1):(3 * K), (2 * K + 1):(3 * K)], sigma[(2 * K + 1):(3 * K)]));    array[N] real mu_rep; // mu replications    mu_rep = normal_rng(X * beta_rep, X * exp(beta_phi_rep));    array[N] int y_rep; // y replications    for(n in 1:N) {      y_rep[n] = skellam_rng(mu_rep[n], abs(mu_rep[n]) + X[n, ] * exp(beta_delta_rep));    }}